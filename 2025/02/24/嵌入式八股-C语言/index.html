<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Ryen">





<title>嵌入式八股_C语言 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ryen&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ryen&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">嵌入式八股_C语言</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Ryen</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 24, 2025&nbsp;&nbsp;23:36:41</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="C语言常见面试题"><a href="#C语言常见面试题" class="headerlink" title="C语言常见面试题"></a>C语言常见面试题</h1><h3 id="1-描述结构体的内存对齐"><a href="#1-描述结构体的内存对齐" class="headerlink" title="1.描述结构体的内存对齐"></a>1.描述结构体的内存对齐</h3><p>结构体的内存对齐是指编译器在分配内存时如何对结构体成员进行排序，以便提高内存访问效率和处理器对齐要求的一种优化技术。</p>
<p>常见的内存对齐规则：</p>
<p><strong>①自然对齐规则：</strong></p>
<p>结构体成员根据自身大小进行依次对齐（1，2，4，8字节边界各自对齐）。</p>
<p><strong>②最大对齐规则：</strong></p>
<p>结构体的全部成员对齐取决于结构体成员中的最大长度。</p>
<p><strong>③填充字节：</strong></p>
<p>为满足对齐要求，编译器可能在结构体成员中插入额外的填充字节，使得所有成员都在适当的地址上。</p>
<p><strong>④指定对齐方式：</strong></p>
<p>特定场景，通过特定的编译器指令会特定的编译选项实现（例：***#pragma pack*** ）。</p>
<h3 id="2-static静态变量和全局变量的区别"><a href="#2-static静态变量和全局变量的区别" class="headerlink" title="2.static静态变量和全局变量的区别"></a>2.static静态变量和全局变量的区别</h3><p><strong>①作用域：</strong></p>
<ul>
<li>全局变量的作用域是整个源文件，在文件中的任何地方都可以访问到。</li>
<li>static静态变量的作用域被限制在声明它的源文件内部，不能被其他文件访问。</li>
</ul>
<p><strong>②链接性：</strong></p>
<ul>
<li>全局变量具有外部链接性，可以被其他文件访问，且在程序中的所有文件都具有相同的实例。</li>
<li>static静态变量具有内部链接性，只能在声明它的源文件中访问，其他文件不能直接访问它。</li>
</ul>
<p><strong>③初始化：</strong></p>
<ul>
<li>全局变量可以显式地初始化，如果没有显式初始化，它们会默认初始化为0值（对于静态存储期的全局变量）或者未定义的值（对于动态存储期的全局变量）。</li>
<li>static静态变量也可以显式初始化，若未进行显式初始化，它们会被默认初始化为0值或用户自己指定的初始值。</li>
</ul>
<p><strong>④生命周期：</strong></p>
<ul>
<li>全局变量和静态变量都具有静态存储期，生命周期从程序启动到程序结束，它们在内存中的位置固定不变。</li>
<li>全局变量和静态变量在程序的整个执行过程中都存在，并且在函数执行中保持其值。</li>
</ul>
<h3 id="3-volatile的作用"><a href="#3-volatile的作用" class="headerlink" title="3.volatile的作用"></a>3.volatile的作用</h3><p>volatile是一个关键字，用于告诉编译器不要对被修饰的变量进行优化，以便程序执行过程中变量的值能及时更新并正确反映其实际状态，主要作用为：</p>
<p><strong>①禁止优化:<strong>编译器在编译过程中可能会对变量进行优化，例如将变量缓存至寄存器以提高访问速度。但对于某些特殊的变量，如“<em>硬件寄存器</em>”、“<em>多线程共享变量</em>”或者<em>在中断服务程序中使用的变量</em>，如果被优化可能导致意外的行为，使用volatile可确保变量的每次访问都*</strong>从内存*</strong>中读取。</p>
<p><strong>②确保可见性：</strong>volatile变量的值可能会被外部因素改变，例如硬件状态的变化或或者其他线程的操作，使用volatile可确保变量的读写操作均在内存中进行而不是在缓存中读取，以确保线程之间的可见性。</p>
<p><strong>③防止编译器重排：</strong>编译器在优化代码时可能会对指令进行重排，但在多线程环境下，这可能导致不正确的执行顺序，使用volatile修饰变量可防止编译器对指令进行重排。</p>
<h3 id="4-malloc的原理"><a href="#4-malloc的原理" class="headerlink" title="4.malloc的原理"></a>4.malloc的原理</h3><p><strong>①内存分配器：</strong>malloc()函数通过内存分配器来分配内存。内存分配器负责管理程序的内存空间，并维护一份可用内存块的列表。常见的内存分配器有基于链表的分配器（如ptmalloc）、堆（heap）管理器等。</p>
<p><strong>②内存分配过程：</strong></p>
<ul>
<li>当调用malloc(size)时，内存分配器会查找可用内存块的列表，尝试找到一个足够大的空闲块，其大小大于或等于size。</li>
<li>如果找到了合适大小的空闲块，将其分配给调用者，然后将其从可用内存块列表移除。</li>
<li>如果未找到合适大小的空闲块，内存分配器会请求更多的内存空间（*通常是通过系统调用如brk(),mmap()*）来扩展堆，以满足分配请求。</li>
<li>分配的内存块通常会包含一些额外的元数据，如大小信息和分配状态等等，以便内存释放时的管理。</li>
</ul>
<p><strong>③内存释放：</strong></p>
<ul>
<li>当调用free(ptr)时，内存分配器会将之前分配的内存块标记为可用，并将其加入可用内存块列表中。</li>
<li>内存分配器通常会合并相邻的空闲块，以避免内存碎片化。</li>
<li>对于常用的内存分配器，内存释放操作并不一定会立即返回内存给操作系统，而是保留在堆中以备将来使用，以提高分配效率。</li>
</ul>
<p><strong>④内存管理策略：</strong></p>
<ul>
<li>内存分配器通常会实现一些策略来优化内存分配和释放的性能，如分配缓存、延迟释放、内存对齐、分配器锁等。</li>
</ul>
<h3 id="5-函数指针和指针函数的区别"><a href="#5-函数指针和指针函数的区别" class="headerlink" title="5.函数指针和指针函数的区别"></a>5.函数指针和指针函数的区别</h3><p><strong>函数指针（Function Pointer）:</strong></p>
<ul>
<li>函数指针是指向函数的指针变量。它存储了函数的地址，可以用来调用相应的函数。</li>
<li>通过函数指针，可以在运行时动态地确定调用哪个函数，从而实现函数的动态调用和多态性。</li>
<li>声明一个函数指针时，需要指定函数的返回类型和参数列表，以确保正确调用函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：声明一个函数指针ptr,指向一个无返回值，参数为整型的函数</span></span><br><span class="line"><span class="type">void</span> (*ptr)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p><strong>指针函数（Pointer to a Function）:</strong></p>
<ul>
<li>指针函数是一个函数，其返回类型是指针，指针函数返回的是指向某种类型的数据。</li>
<li>指针函数通常用于动态地分配内存、构建数据结构或者返回指向函数的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：声明一个指针函数，返回一个指向整型的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">func</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h3 id="6-使用宏定义实现交换数据，但不能使用中间变量"><a href="#6-使用宏定义实现交换数据，但不能使用中间变量" class="headerlink" title="6.使用宏定义实现交换数据，但不能使用中间变量"></a>6.使用宏定义实现交换数据，但不能使用中间变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP_NO_TEMP(a, b) \</span></span><br><span class="line"><span class="meta">do &#123; 			\</span></span><br><span class="line"><span class="meta">    (a) ^= (b); \</span></span><br><span class="line"><span class="meta">    (b) ^= (a); \</span></span><br><span class="line"><span class="meta">    (a) ^= (b); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>^ 异或（XOR） ： 两值相同则为0，不同为1。</li>
</ul>
<h3 id="7-宏定义写一个循环"><a href="#7-宏定义写一个循环" class="headerlink" title="7.宏定义写一个循环"></a>7.宏定义写一个循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOOP(start, end, statement) \</span></span><br><span class="line"><span class="meta">do &#123;  \</span></span><br><span class="line"><span class="meta">    for(int i = (start);i &lt; (end);i++) &#123;  \</span></span><br><span class="line"><span class="meta">        statement;   \</span></span><br><span class="line"><span class="meta">    &#125;  \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LOOP(<span class="number">0</span>, <span class="number">5</span>, <span class="built_in">printf</span>(<span class="string">&quot;FK!\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-判断当前系统是大端还是小端"><a href="#8-判断当前系统是大端还是小端" class="headerlink" title="8.判断当前系统是大端还是小端"></a>8.判断当前系统是大端还是小端</h3><ul>
<li><strong>大端：</strong>高位字节存储在低地址（类似正常书写数字的顺序，从左到右，高位到低位）。</li>
<li><strong>小端：</strong>低位字节存储在低地址。</li>
</ul>
<p><strong>方法1：</strong></p>
<p>创建一个包含多字节整数的union，然后检查联合体的首字节和末字节的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c[<span class="keyword">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line">    &#125; u;</span><br><span class="line">    </span><br><span class="line">    u.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u.c[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端 LE\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端 BE\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法2：</strong></p>
<p>使用指针判断大小端，如检查一个整数的首字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 使用char指针指向tmp的地址，char指针仅访问地址的第一个字节</span></span><br><span class="line">    <span class="type">char</span> *ptr = (<span class="type">char</span>*)&amp;tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*ptr == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端 LE\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端 BE\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-为何64位系统下的指针大小与32位系统下的大小不一样"><a href="#9-为何64位系统下的指针大小与32位系统下的大小不一样" class="headerlink" title="9.为何64位系统下的指针大小与32位系统下的大小不一样"></a>9.为何64位系统下的指针大小与32位系统下的大小不一样</h3><p>在32位系统中，地址总线的宽度为32位，因此系统可寻址的内存空间为2^32（4GB）个字节。因此一个指针通常需要32位（4字节）来存储地址，以便指向整个地址空间中的任意位置。</p>
<p>而64位系统，地址总线宽度为64位，系统可寻址的内存空间为2^64个字节，故一个指针通常需要64位（8字节）来存储地址。</p>
<h3 id="10-static-volatile-const这些关键字的作用"><a href="#10-static-volatile-const这些关键字的作用" class="headerlink" title="10.static,volatile,const这些关键字的作用"></a>10.static,volatile,const这些关键字的作用</h3><p><strong>①static:</strong></p>
<ul>
<li>在函数内部使用static关键字声明的<em><strong>局部变量</strong></em>，可以实现状态的持久性，即变量的值在函数调用之间保持不变。</li>
<li>在<em><strong>函数</strong></em>声明前使用static关键字，可以将函数的作用域限定在当前文件内，实现信息隐藏和模块化编程。</li>
<li>在<em><strong>全局变量</strong></em>前使用static关键字，可以将全局变量的作用域限定在当前文件内，避免与其他文件中同名的全局变量产生冲突，起到了局部化的作用。</li>
</ul>
<p><strong>②volatile：</strong></p>
<ul>
<li>volatile关键字用来告诉编译器，某个变量的值可能会在程序执行过程中被意外修改，因此编译器不应该对该变量进行优化，以确保每次访问都是从内存中真实的读取。</li>
<li>通常用于多线程环境下的共享变量、外设寄存器以及信号处理等场景，以防止编译器对这些变量的访问进行优化，保证程序的正确性。</li>
</ul>
<p><strong>③const：</strong></p>
<ul>
<li>const关键字用来定义常量，表示该变量的值在程序运行期间不会改变。它可以用来修饰变量，表示该变量的值不可变，也可以用来修饰函数参数，表示函数在执行过程中不会改变该参数的值。</li>
<li>在指针变量前使用const关键字，可以声明指针指向的内容为只读，防止通过该指针修改被指向的内容。</li>
<li>在函数返回值前使用const关键字，表示函数返回的是一个常量值，调用者不应该试图修改它。</li>
</ul>
<h3 id="11-程序分为哪几个段"><a href="#11-程序分为哪几个段" class="headerlink" title="11.程序分为哪几个段"></a>11.程序分为哪几个段</h3><p><strong>①代码段（Text Segment）：</strong></p>
<ul>
<li>也称为只读代码段或程序段，用于存储程序的可执行指令。</li>
<li><strong>通常是只读的</strong>，以防止程序意外修改自身的指令。</li>
<li><em>代码段在程序加载到内存时被载入</em>，并且通常是共享的，多个进程可以共享同一个程序的代码段，以节省内存空间。</li>
</ul>
<p><strong>②数据段（Data Segment）：</strong></p>
<ul>
<li>用于存储已初始化的全局变量和静态变量。</li>
<li><em>数据段在程序加载到内存时被载入</em>，并且<strong>通常是可读写的</strong>。</li>
</ul>
<p><strong>③BSS段（Block Started by Symbol）：</strong></p>
<ul>
<li>用于存储未初始化的全局变量和静态变量，通常用0值填充。</li>
<li>BSS段在程序加载到内存时被分配空间，但不需要载入具体的数据。</li>
<li>当程序启动时，操作系统会将BSS段的数据初始化为零。</li>
</ul>
<p><strong>④堆（Heap）:</strong></p>
<ul>
<li>用于动态分配内存，通常由程序员在运行时手动管理。</li>
<li>堆的大小可以根据程序运行的运行动态增加或减少。</li>
<li>堆的分配和释放通常使用malloc&#x2F;free等函数进行操作。</li>
</ul>
<p><strong>⑤栈（Stack）:</strong></p>
<ul>
<li>用于存储函数的局部变量、函数的参数值以及函数调用时的上下文信息。</li>
<li>栈是一种先进后出（LIFO）的数据结构，每次函数调用时，都会在栈上分配一块称为栈帧的空间，用于存储函数调用相关的数据。</li>
<li>函数返回时，对应的栈帧会被弹出，释放相应的空间。</li>
</ul>
<h3 id="12-extern-“C”的作用"><a href="#12-extern-“C”的作用" class="headerlink" title="12.extern “C”的作用"></a>12.extern “C”的作用</h3><p>extern “C”是C++中的一个特殊用法，它用于告诉编译器在处理特定的函数和变量声明时要使用C语言的命名约定，而不是C++的命名约定。</p>
<p><strong>①解决链接问题：</strong></p>
<ul>
<li>当在C++程序中调用C语言编写的库时，由于C++和C的函数命名约定不同，可能会导致链接失败。使用extern “C”可正确链接C函数。</li>
</ul>
<p><strong>②确保函数名不被C++的名称修饰器修改：</strong></p>
<ul>
<li>在C++中，函数名可能经过名称修饰（Name Mangling）以支持函数重载和命名空间等待性。但是C语言不支持此功能，因此需要extern “C”来确保C函数名不被修改。</li>
</ul>
<p><strong>③与C语言库交互：</strong></p>
<ul>
<li>当在C++使用C语言编写的库时，使用extern “C”可以确保C++代码正确地与C函数和变量进行交换，而不会受到C++的名称修饰的影响。</li>
</ul>
<h3 id="13-define中-和-的含义"><a href="#13-define中-和-的含义" class="headerlink" title="13.define中#和##的含义"></a>13.define中#和##的含义</h3><p>预处理器的两个特殊符号，用于宏定义和宏展开。</p>
<p><strong>#：字符串化操作符（Stringize Operator）:</strong></p>
<ul>
<li>在宏定义中，#被用来将参数转换为字符串常量。</li>
<li>当在宏的参数前面使用#时，该参数会被转换成一个字符串，并作为宏展开的结果。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TMP(x) #x</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,TMP(Hello)); <span class="comment">// 输出Hello</span></span><br></pre></td></tr></table></figure>

<p><strong>##：连接操作符（Token Pasting Operator）:</strong></p>
<ul>
<li>##用于连接两个符号或参数，产生一个新的符号。</li>
<li>连接操作符##可以将两个相邻的标识符、宏参数或标记（token）连接成一个单独的标识符。</li>
<li>通常用于宏定义中动态生成标识符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONNECT(x,y) x##y</span></span><br><span class="line"><span class="type">int</span> xy = CONNECT(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// xy = 1020</span></span><br></pre></td></tr></table></figure>



<h3 id="14-sizeof和strlen的区别"><a href="#14-sizeof和strlen的区别" class="headerlink" title="14.sizeof和strlen的区别"></a>14.sizeof和strlen的区别</h3><p><strong>sizeof:</strong></p>
<ul>
<li>sizeof是C和C++中的一个<em><strong>运算符，而不是函数</strong></em>。</li>
<li>它用于计算数据类型或变量在内存中所占的字节数。</li>
<li>sizeof可以用于任何数据类型、变量或表达式，包括基本数据类型、结构体、数组等。</li>
<li>在编译时计算，返回的是数据类型或变量所占内存空间的大小，单位为字节（byte）。</li>
</ul>
<p><strong>strlen：</strong></p>
<ul>
<li>strlen是C和C++中的一个<em><strong>函数</strong></em>，用于计算字符串的长度，即字符串中的字符数（不包括结尾的空字符\0）。</li>
<li>它接受一个以空字符结尾的字符串作为参数，并返回字符串中的字符数。</li>
<li>strlen在运行时遍历字符串，直到遇到空字符\0才停止计数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> length = <span class="built_in">strlen</span>(str); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>sizeof是一个运算符，用于计算数据类型或变量的大小（以字节为单位）。</li>
<li>strlen是一个函数，用于计算以空字符结尾的字符串中的字符数。</li>
</ul>
<h3 id="15-什么是野指针"><a href="#15-什么是野指针" class="headerlink" title="15.什么是野指针"></a>15.什么是野指针</h3><p>野指针（dangling pointer）是指指向已经被释放或者无效的内存地址的指针。导致程序的不可预知行为，访问野指针指向的内存区域可能导致内存访问错误（segmentation fault）或者数据损坏。</p>
<p>野指针可能发生的场景：</p>
<p><strong>释放了指针所指向的内存，但没有将指针置为NULL：</strong></p>
<ul>
<li>当使用了free()或delete释放动态分配的内存后，如果没有将指针置为NULL，那么指针仍然保留了之前所指向的内存地址，此时该指针就成为野指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 将指针置为NULL，避免成为野指针</span></span><br></pre></td></tr></table></figure>

<p><strong>指针超出了作用域但未置为NULL:</strong></p>
<ul>
<li>当指针指向的对象超出了其作用域，但没有将指针置为NULL，该指针也可能成为野指针。</li>
</ul>
<p><strong>指向已被释放的栈内存：</strong></p>
<ul>
<li>如果一个指针指向了一个局部变量，而该局部变量已超过其作用域，则该指针也会成为野指针。</li>
</ul>
<h3 id="16-为何会发生内存泄漏，如何解决内存泄漏？"><a href="#16-为何会发生内存泄漏，如何解决内存泄漏？" class="headerlink" title="16.为何会发生内存泄漏，如何解决内存泄漏？"></a>16.为何会发生内存泄漏，如何解决内存泄漏？</h3><p>内存泄漏指程序中动态分配的内存在不再需要时没有被正确释放,从而导致系统的可用内存减少，并可能影响系统性能或导致程序运行不稳定。以下场景高频出现：</p>
<ol>
<li><strong>未释放动态分配的内存：</strong>当程序使用malloc、calloc、new等函数在堆上分配内存，但没有使用相应的释放函数（如free、delete）释放这些内存时，就会发生内存泄漏。</li>
<li><strong>丢失指向动态分配内存的指针：</strong>当指向动态分配的内存的指针丢失时，无法再释放这部分内存，从而导致内存泄漏。这种情况通常发生在指针被重复赋值或者指针被覆盖的情况下。</li>
</ol>
<p>解决内存泄漏的方法包括：</p>
<ol>
<li><strong>严格管理动态分配的内存：</strong>确保在动态分配内存后，及时使用相应的释放函数将其释放，以避免内存泄漏。</li>
<li><strong>使用智能指针：</strong>智能指针是<strong>C++<strong>中的一种特殊指针类型，它可以在对象不再需要时自动释放相关的内存。它们在</strong>对象生命周期结束时自动调用析构函数</strong>来释放内存。</li>
<li><strong>良好的代码编写规范</strong></li>
</ol>
<h3 id="17-数组指针和指针数组"><a href="#17-数组指针和指针数组" class="headerlink" title="17.数组指针和指针数组"></a>17.数组指针和指针数组</h3><p><strong>数组指针（Pointer to an Array）：</strong></p>
<ul>
<li>数组指针是指向数组的指针，它指向数组而不是数组的某个元素。</li>
<li>数组指针本身是一个指针变量，它存储的是数组的首地址。</li>
<li>数组指针的声明方式为type(*ptr)[size],其中ptr是指向数组的指针，type是数组元素的类型，size为数组大小。</li>
<li>使用数组指针可以方便地对整个数组进行操作，例如传递数组给函数或者动态分配多维数组内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 声明一个包含5个元素的整形数组</span></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">5</span>]; <span class="comment">// 声明一个指向包含5个元素的整型数组的指针</span></span><br><span class="line">ptr = &amp;arr; <span class="comment">// 将指针指向数组</span></span><br></pre></td></tr></table></figure>

<p><strong>指针数组（Array of Pointers）：</strong></p>
<ul>
<li>指针数组是一个数组，其中的每个元素都是一个指针。</li>
<li>指针数组的声明方式是type *ptr[size],其中ptr是指针数组的名称，type是指针所指向的数据类型，size是数组的大小。</li>
<li>指针数组的每个元素存储的是指针，指向某个特定类型的数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr[<span class="number">5</span>]; <span class="comment">// 声明一个包含5个元素的指针数组，每个元素都是指向整型数据的指针</span></span><br><span class="line"><span class="type">int</span> val1 = <span class="number">10</span>,val2 = <span class="number">20</span>,val3 = <span class="number">30</span>;</span><br><span class="line">ptr[<span class="number">0</span>] = &amp;val1; <span class="comment">// 指针数组的第一个元素指向val1</span></span><br><span class="line">ptr[<span class="number">1</span>] = &amp;val2; </span><br><span class="line">ptr[<span class="number">2</span>] = &amp;val3; </span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>数组指针指向整个数组，而指针数组是一个数组，其中的每个元素都是指针。</li>
<li>使用数组指针可以方便地对整个数组进行操作，而指针数组可以用于存储一组指针，每个指针指向不同的数据或对象。</li>
</ul>
<h3 id="18-局部变量和全局变量的区别"><a href="#18-局部变量和全局变量的区别" class="headerlink" title="18.局部变量和全局变量的区别"></a>18.局部变量和全局变量的区别</h3><ol>
<li><strong>作用域：</strong><ul>
<li><strong>全局变量：</strong>声明在程序的任何函数之外，它们可以被程序中的所有函数访问。全局变量的作用域从声明处开始，直到文件的末尾。</li>
<li><strong>局部变量：</strong>声明在函数内部，只能在声明它们的函数内部访问。局部变量的作用域从声明处开始，直到函数的结束处。</li>
</ul>
</li>
<li><strong>生存周期</strong><ul>
<li><strong>全局变量：</strong>在程序运行期间始终存在，直到程序结束。</li>
<li><strong>局部变量：</strong>仅限于声明它们的函数的执行期间，当函数执行结束时，局部变量被销毁，并在下一次函数调用时重新创建。</li>
</ul>
</li>
<li><strong>存储位置</strong><ul>
<li><strong>全局变量：</strong>数据段（data segment）它们在程序启动时被初始化，并且在程序运行期间保持不变。</li>
<li><strong>局部变量：</strong>存储在栈（stack）中，它们在函数执行时动态分配内存，当函数执行结束时自动释放。</li>
</ul>
</li>
<li><strong>作用域：</strong><ul>
<li><strong>全局变量：</strong>如果未显式初始化，它们的默认值通常是0或NULL，取决于变量的类型。</li>
<li><strong>局部变量：</strong>不会被自动初始化，它们的值取决于它们在声明时所处的内存位置，局部变量的值是不确定的。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>全局变量具有全局作用域，在整个程序中都可访问，而局部变量有局部作用域，仅限声明于它们的函数内部访问。</li>
<li>全局变量的生命周期长，存储在程序的数据段中,而局部变量的生命周期短，存储在栈中。</li>
<li>全局变量在程序启动时被初始化，而局部变量不会自动初始化，它们的值取决于其在内存中的位置。</li>
</ul>
<h3 id="19-const关键字的作用"><a href="#19-const关键字的作用" class="headerlink" title="19.const关键字的作用"></a>19.const关键字的作用</h3><p>const关键字常用于声明常量，其作用是告诉编译器该变量的值在程序执行过程中不能被修改，有以下场景：</p>
<p><strong>常量声明：</strong>声明一个不可修改的常量,例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>函数参数声明：</strong>声明函数的参数为只读，以防止函数修改传入的参数值。</li>
<li><strong>指针和const：</strong>使用const修饰指针时，可以使指针指向的对象成为常量，即指针所指向的内存内容不能修改，但指针本身是可以修改的。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;num; <span class="comment">// ptr是一个指向常量的指针，指向的内容不能被修改</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr1 = &amp;num; <span class="comment">// ptr是一个指向整数的常量指针，指针本身不能被修改</span></span><br></pre></td></tr></table></figure>

<p>可以用指针来修改const修饰的<em><strong>局部变量</strong></em>的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = (<span class="type">int</span>*)&amp;num; <span class="comment">// 将指针指向 const int 变量num</span></span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">// 使用指针修改const常量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num:%d\n&quot;</span>,num); <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20-宏定义define和typedef的区别"><a href="#20-宏定义define和typedef的区别" class="headerlink" title="20.宏定义define和typedef的区别"></a>20.宏定义define和typedef的区别</h3><ol>
<li><strong>作用域不同：</strong><ul>
<li>#define:宏定义是一种简单的文本替换机制，它在代码中被预处理器处理，替换所有出现的宏定义，不涉及作用域的概念。宏定义的作用范围从定义处开始，一直到文件的末尾或者#undef指令。</li>
<li>typedef:类型定义是在编译阶段进行处理的，它在指定的作用域内为类型创建一个新的名称，用于增加代码的可读性和可维护性。</li>
</ul>
</li>
<li><strong>类型安全性：</strong><ul>
<li>#define:宏定义没有类型检查，只是单纯地进行文本替换，存在风险。</li>
<li>typedef:类型定义提供了类型安全性，因为它只能用于定义新的类型名称，而不是进行文本替换。</li>
</ul>
</li>
<li><strong>用途：</strong><ul>
<li>#define:宏定义通常用于定义常量、函数或者复杂的代码片段，它们可以接受参数，并且在预处理阶段进行简单的文本替换。</li>
<li>typedef:类型定义用于创建新的类型名称，以增加代码的可读性，并且使代码容易理解。</li>
</ul>
</li>
<li><strong>语法:</strong><ul>
<li>#define:#define + 宏名称 + 替换文本。</li>
<li>typedef:typedef + 原类型 + 新类型名称。</li>
</ul>
</li>
</ol>
<h3 id="21-struct和union的区别"><a href="#21-struct和union的区别" class="headerlink" title="21.struct和union的区别"></a>21.struct和union的区别</h3><ol>
<li><strong>存储方式：</strong>struct中各个成员在内存中占据不同的内存空间，每个成员都有自己的地址；而union中的所有成员共享同一片内存空间，不同成员在不同时间存储于同一地址，并且union的大小取决于最大成员的大小。</li>
<li><strong>内存使用：</strong>struct在内存中为每个成员分配独立的空间，因此它的大小等于所有成员大小的总和；union的大小取决于最大成员的大小。</li>
<li><strong>数据访问：</strong>struct中的成员可以同时被访问和使用，每个成员都有自己的标识和地址；而union中只能同时访问一个成员，其他成员的访问必须在使用前重新分配。</li>
</ol>
<h3 id="22-生成可执行程序的步骤"><a href="#22-生成可执行程序的步骤" class="headerlink" title="22.生成可执行程序的步骤"></a>22.生成可执行程序的步骤</h3><ol>
<li><strong>预处理（Preprocessing）：</strong>实际编译前对源代码进行处理的阶段。在这个阶段，预处理器会根据预处理指令（以“#”开头）对源代码进行处理。预处理器可以进行宏替换、条件编译等操作。它会展开宏定义，将头文件包含到源代码中，并去除注释。预处理器输出的文件是一个处理过的源代码文件通常以.i或.ii为扩展名。</li>
<li><strong>汇编（Assembly）：</strong>汇编是预处理后的源代码转化为汇编语言的过程。汇编语言使用助记符（mnemonic）代表指令、寄存器和内存地址等。汇编器将每一条汇编语言翻译成机器语言指令，并生成目标文件（object file）。目标文件通常以.o或者.obj为扩展名。</li>
<li><strong>编译（Compilation）：</strong>编译是将汇编语言翻译成机器码的过程。编译器会对每个汇编指令进行语法和语义分析，并生成与目标硬件平台兼容的机器码。编译器还会对源代码进行优化，以提高程序性能和执行效率。编译器输出的文件通常也是目标文件，扩展名和汇编阶段生成的目标文件相同。</li>
<li><strong>链接（Linking）：</strong>链接是将多个目标文件和库文件组合成一个可执行文件的过程。在编译的过程中，有些功能可能在外部库中完成，而不是在源代码中实现。链接器的任务是解析这些外部符号引用，将其与对应的地址关联起来，以创建一个完整的可执行程序。</li>
</ol>
<h3 id="23-include的作用"><a href="#23-include的作用" class="headerlink" title="23.#include的作用"></a>23.#include的作用</h3><p>#include是一个预处理指令，它在C和C++编程语言中用于包含头文件或者引入其他源代码文件。</p>
<p>头文件包含了函数、变量声明、宏定义等信息，可以在源代码中引入这些声明而无需重复写入。使用#include可以将头文件的内容插入到源代码文件中，在编译前扩展宏、替换宏定义，确保相应的声明在编译中可见。</p>
<h3 id="24-strcpy-与memcpy-的区别"><a href="#24-strcpy-与memcpy-的区别" class="headerlink" title="24.strcpy()与memcpy()的区别"></a>24.strcpy()与memcpy()的区别</h3><ol>
<li><strong>参数类型：</strong><ul>
<li>strcpy()接受两个参数，均为指向字符数组的指针。第一个参数是目标字符数组，第二个参数是源字符数组。</li>
<li>memcpy()接受三个参数，第一个参数是目标内存块的指针，第二个参数是源内存块的指针，第三个参数是要复制的字节数。</li>
</ul>
</li>
<li><strong>适用范围：</strong><ul>
<li>strcpy()主要用于复制字符串，即以空字符(\0)结尾的字符数组。它会从源字符串的首地址开始，一直复制到遇到空字符为止（包括空字符）。</li>
<li>memcpy()用于复制任意类型的内存块，不仅仅局限于字符串。它会按照指定的字节数将源内存块的内容复制到目标内存块。</li>
</ul>
</li>
<li><strong>字符串处理：</strong><ul>
<li>strcpy()会自动在目标字符串的末尾添加空字符，以确保复制的内容形成一个完整的字符串。</li>
<li>memcpy()不会自动添加空字符，它只负责按照指定的字节数进行字节级别的复制。</li>
</ul>
</li>
<li><strong>内存重叠:</strong><ul>
<li>strcpy()在处理内存重叠的情况下是不安全的，可能导致未定义的行为。例如：当目标字符串与源字符串完全重叠时，复制过程中可能会覆盖尚未复制的内容。</li>
<li>memcpy()允许处理内存重叠，它会按照字节进行复制，不会收到内存重叠的影响。</li>
</ul>
</li>
</ol>
<h3 id="25-宏定义与inline函数的区别"><a href="#25-宏定义与inline函数的区别" class="headerlink" title="25.宏定义与inline函数的区别"></a>25.宏定义与inline函数的区别</h3><ol>
<li><strong>语法与类型安全性：</strong><ul>
<li>宏定义是以文本替换的方式工作，没有语法结构，因此不进行参数类型检查，容易引发问题。</li>
<li>inline函数使用函数语法，具有参数类型检查，具有良好的类型安全性。它们在编译时执行类型检查，并且会进行函数调用和返回的正常流程。</li>
</ul>
</li>
<li><strong>作用域与内存空间：</strong><ul>
<li>宏定义是全局的，不受作用域和命名空间的限制，它们被展开时会直接替换成相应的代码片段。</li>
<li>inline函数受到作用域和命名空间的限制。它们需要声明和定义，并遵循C&#x2F;C++命名约定。</li>
</ul>
</li>
<li><strong>可读性与调试：</strong><ul>
<li>宏定义进行简单的文本替换，展开后的代码可能很难阅读与理解。且在调试时，宏定义可能会给出错误的行号和函数名。</li>
<li>inline函数具有函数语法结构，代码有更好的可读性。在调试中，可以正常跟踪函数调用栈获取准确的行号和函数。</li>
</ul>
</li>
<li><strong>名称冲突与重复定义:</strong><ul>
<li>宏定义没有作用域和命名空间的概念，可以导致名称冲突和重复定义的问题。</li>
<li>inline函数受到作用域和命名空间的限制。并遵循C&#x2F;C++命名约定，能有效避免名称冲突和重复定义。</li>
</ul>
</li>
</ol>
<h3 id="26-不使用库函数实现strcpy-strcmp-strcat-strlen"><a href="#26-不使用库函数实现strcpy-strcmp-strcat-strlen" class="headerlink" title="26.不使用库函数实现strcpy,strcmp,strcat,strlen"></a>26.不使用库函数实现strcpy,strcmp,strcat,strlen</h3><p><strong>strcpy:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FAKE_Strcpy</span><span class="params">(<span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *origin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*origin) &#123;</span><br><span class="line">        *target++ = *origin++;</span><br><span class="line">    &#125;</span><br><span class="line">    *target = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> test[<span class="number">20</span>];</span><br><span class="line">    FAKE_Strcpy(test, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,test);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>strcmp:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">FAKE_Strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>((*str1 &amp;&amp; *str2) &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*str1 - *str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;AAACCB&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;ACAABB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> tmp = FAKE_Strcmp(str1, str2);</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1比str2的字典序在后\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1比str2的字典序在前\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1和str2的字典序一致\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>strcat:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FAKE_Strcat</span><span class="params">(<span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*str1) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*str2) &#123;</span><br><span class="line">        *str1++ = *str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    *str1 = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    FAKE_Strcat(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>strlen:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">FAKE_Strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> len = FAKE_Strlen(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,len);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Ryen</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/02/24/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1-C%E8%AF%AD%E8%A8%80/">http://example.com/2025/02/24/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1-C%E8%AF%AD%E8%A8%80/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span></span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%9A%8F%E7%AC%94/"># 随笔</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/02/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1-Linux/">嵌入式八股_Linux</a>
            
            
            <a class="next" rel="next" href="/2023/08/17/day8/">【代码随想录】 Day8 | 344.反转字符串  541. 反转字符串II 剑指Offer 05.替换空格 151.翻转字符串里的单词 剑指Offer58-II.左旋转字符串</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Ryen | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>